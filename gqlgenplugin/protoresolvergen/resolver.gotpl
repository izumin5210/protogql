{{ reserveImport "context" }}
{{ reserveImport "fmt" }}

{{ range $resolver := .Resolvers -}}
	func (r *{{ $resolver.Object | resolverImplementationName }}) {{ $resolver.GoFieldName }}{{ $resolver.ShortProtoResolverDeclaration }} {
		panic(fmt.Errorf("not implemented"))
	}
{{ end }}

{{ range $obj := .Objects -}}
	// {{$obj.Name}} returns {{ $obj.ResolverInterface | ref }} implementation.
	func (r *{{$.ResolverType}}) {{$obj.Name}}() {{ $obj.ResolverInterface | ref }} { return &{{ $obj | resolverAdapterName }}{&{{ $obj | resolverImplementationName }}{r}} }

	type {{ $obj | resolverImplementationName }} struct { *{{ $.ResolverType }} }
{{ end }}


{{ range $resolver := .Resolvers -}}
	func (a *{{ $resolver.Object | resolverAdapterName }}) {{ $resolver.GoFieldName }}{{ $resolver.ShortResolverDeclaration }} {
		resp, err := a.protoResolver.{{ $resolver.GoFieldName }}({{ $resolver.ArgList }})
		if err != nil {
			return nil, err
		}
		{{ if $resolver.TypeReference.IsScalar -}}
			return resp, nil
		{{ else }}
			return {{ $resolver.ResolverModelFromProtoFunc }}(resp), nil
		{{ end }}
	}
{{ end }}

{{ range $obj := .Objects -}}
	type {{ $obj | resolverAdapterName }} struct { protoResolver *{{ $obj | resolverImplementationName }} }
{{ end }}
