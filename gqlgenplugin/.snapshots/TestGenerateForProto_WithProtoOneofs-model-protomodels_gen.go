// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	oneof_pb "apis/go/oneof"
)

type Entry struct {
	AuthorID int32
	Content  EntryContent
}

func EntryListFromRepeatedProto(in []*oneof_pb.Entry) []*Entry {
	out := make([]*Entry, len(in))
	for i, m := range in {
		out[i] = EntryFromProto(m)
	}
	return out
}

func EntryFromProto(in *oneof_pb.Entry) *Entry {
	out := &Entry{
		AuthorID: in.GetAuthorId(),
		Content:  EntryContentFromProto(in.GetContent()),
	}

	return out
}

func EntryListToRepeatedProto(in []*Entry) []*oneof_pb.Entry {
	out := make([]*oneof_pb.Entry, len(in))
	for i, m := range in {
		out[i] = EntryToProto(m)
	}
	return out
}

func EntryToProto(in *Entry) *oneof_pb.Entry {
	out := &oneof_pb.Entry{
		AuthorId: in.AuthorID,
	}
	switch m := in.Content.(type) {
	case *Text:
		out.Content = Entry_TextToProto(m)
	case *Image:
		out.Content = Entry_ImageToProto(m)
	case *Link:
		out.Content = Entry_LinkToProto(m)
	}

	return out
}

type EntryInput struct {
	AuthorID int32
	// At most one field, `text`, `image`, and `link` will be set at the same time.
	Text *TextInput
	// At most one field, `text`, `image`, and `link` will be set at the same time.
	Image *ImageInput
	// At most one field, `text`, `image`, and `link` will be set at the same time.
	Link *LinkInput
}

func EntryInputListFromRepeatedProto(in []*oneof_pb.Entry) []*EntryInput {
	out := make([]*EntryInput, len(in))
	for i, m := range in {
		out[i] = EntryInputFromProto(m)
	}
	return out
}

func EntryInputFromProto(in *oneof_pb.Entry) *EntryInput {
	out := &EntryInput{
		AuthorID: in.GetAuthorId(),
	}
	if m := in.GetText(); m != nil {
		out.Text = TextInputFromProto(m)
	}
	if m := in.GetImage(); m != nil {
		out.Image = ImageInputFromProto(m)
	}
	if m := in.GetLink(); m != nil {
		out.Link = LinkInputFromProto(m)
	}

	return out
}

func EntryInputListToRepeatedProto(in []*EntryInput) []*oneof_pb.Entry {
	out := make([]*oneof_pb.Entry, len(in))
	for i, m := range in {
		out[i] = EntryInputToProto(m)
	}
	return out
}

func EntryInputToProto(in *EntryInput) *oneof_pb.Entry {
	out := &oneof_pb.Entry{
		AuthorId: in.AuthorID,
	}

	return out
}

type Image struct {
	ID     int32
	URL    string
	Width  uint32
	Height uint32
}

func ImageListFromRepeatedProto(in []*oneof_pb.Image) []*Image {
	out := make([]*Image, len(in))
	for i, m := range in {
		out[i] = ImageFromProto(m)
	}
	return out
}

func ImageFromProto(in *oneof_pb.Image) *Image {
	out := &Image{
		ID:     in.GetId(),
		URL:    in.GetUrl(),
		Width:  in.GetWidth(),
		Height: in.GetHeight(),
	}

	return out
}

func ImageListToRepeatedProto(in []*Image) []*oneof_pb.Image {
	out := make([]*oneof_pb.Image, len(in))
	for i, m := range in {
		out[i] = ImageToProto(m)
	}
	return out
}

func ImageToProto(in *Image) *oneof_pb.Image {
	out := &oneof_pb.Image{
		Id:     in.ID,
		Url:    in.URL,
		Width:  in.Width,
		Height: in.Height,
	}

	return out
}

type ImageInput struct {
	ID     int32
	URL    string
	Width  uint32
	Height uint32
}

func ImageInputListFromRepeatedProto(in []*oneof_pb.Image) []*ImageInput {
	out := make([]*ImageInput, len(in))
	for i, m := range in {
		out[i] = ImageInputFromProto(m)
	}
	return out
}

func ImageInputFromProto(in *oneof_pb.Image) *ImageInput {
	out := &ImageInput{
		ID:     in.GetId(),
		URL:    in.GetUrl(),
		Width:  in.GetWidth(),
		Height: in.GetHeight(),
	}

	return out
}

func ImageInputListToRepeatedProto(in []*ImageInput) []*oneof_pb.Image {
	out := make([]*oneof_pb.Image, len(in))
	for i, m := range in {
		out[i] = ImageInputToProto(m)
	}
	return out
}

func ImageInputToProto(in *ImageInput) *oneof_pb.Image {
	out := &oneof_pb.Image{
		Id:     in.ID,
		Url:    in.URL,
		Width:  in.Width,
		Height: in.Height,
	}

	return out
}

type Link struct {
	ID  int32
	URL string
}

func LinkListFromRepeatedProto(in []*oneof_pb.Link) []*Link {
	out := make([]*Link, len(in))
	for i, m := range in {
		out[i] = LinkFromProto(m)
	}
	return out
}

func LinkFromProto(in *oneof_pb.Link) *Link {
	out := &Link{
		ID:  in.GetId(),
		URL: in.GetUrl(),
	}

	return out
}

func LinkListToRepeatedProto(in []*Link) []*oneof_pb.Link {
	out := make([]*oneof_pb.Link, len(in))
	for i, m := range in {
		out[i] = LinkToProto(m)
	}
	return out
}

func LinkToProto(in *Link) *oneof_pb.Link {
	out := &oneof_pb.Link{
		Id:  in.ID,
		Url: in.URL,
	}

	return out
}

type LinkInput struct {
	ID  int32
	URL string
}

func LinkInputListFromRepeatedProto(in []*oneof_pb.Link) []*LinkInput {
	out := make([]*LinkInput, len(in))
	for i, m := range in {
		out[i] = LinkInputFromProto(m)
	}
	return out
}

func LinkInputFromProto(in *oneof_pb.Link) *LinkInput {
	out := &LinkInput{
		ID:  in.GetId(),
		URL: in.GetUrl(),
	}

	return out
}

func LinkInputListToRepeatedProto(in []*LinkInput) []*oneof_pb.Link {
	out := make([]*oneof_pb.Link, len(in))
	for i, m := range in {
		out[i] = LinkInputToProto(m)
	}
	return out
}

func LinkInputToProto(in *LinkInput) *oneof_pb.Link {
	out := &oneof_pb.Link{
		Id:  in.ID,
		Url: in.URL,
	}

	return out
}

type Text struct {
	ID   int32
	Body string
}

func TextListFromRepeatedProto(in []*oneof_pb.Text) []*Text {
	out := make([]*Text, len(in))
	for i, m := range in {
		out[i] = TextFromProto(m)
	}
	return out
}

func TextFromProto(in *oneof_pb.Text) *Text {
	out := &Text{
		ID:   in.GetId(),
		Body: in.GetBody(),
	}

	return out
}

func TextListToRepeatedProto(in []*Text) []*oneof_pb.Text {
	out := make([]*oneof_pb.Text, len(in))
	for i, m := range in {
		out[i] = TextToProto(m)
	}
	return out
}

func TextToProto(in *Text) *oneof_pb.Text {
	out := &oneof_pb.Text{
		Id:   in.ID,
		Body: in.Body,
	}

	return out
}

type TextInput struct {
	ID   int32
	Body string
}

func TextInputListFromRepeatedProto(in []*oneof_pb.Text) []*TextInput {
	out := make([]*TextInput, len(in))
	for i, m := range in {
		out[i] = TextInputFromProto(m)
	}
	return out
}

func TextInputFromProto(in *oneof_pb.Text) *TextInput {
	out := &TextInput{
		ID:   in.GetId(),
		Body: in.GetBody(),
	}

	return out
}

func TextInputListToRepeatedProto(in []*TextInput) []*oneof_pb.Text {
	out := make([]*oneof_pb.Text, len(in))
	for i, m := range in {
		out[i] = TextInputToProto(m)
	}
	return out
}

func TextInputToProto(in *TextInput) *oneof_pb.Text {
	out := &oneof_pb.Text{
		Id:   in.ID,
		Body: in.Body,
	}

	return out
}

type EntryContent interface {
	IsEntryContent()
}

func (*Text) IsEntryContent() {}

func (*Image) IsEntryContent() {}

func (*Link) IsEntryContent() {}

func EntryContentFromProto(in interface{}) EntryContent {
	switch m := in.(type) {
	case *oneof_pb.Entry_Text:
		return TextFromProto(m.Text)
	case *oneof_pb.Entry_Image:
		return ImageFromProto(m.Image)
	case *oneof_pb.Entry_Link:
		return LinkFromProto(m.Link)
	default:
		panic("not supported")
	}
}
func Entry_TextToProto(in *Text) *oneof_pb.Entry_Text {
	return &oneof_pb.Entry_Text{TextToProto(in)}
}

func Entry_ImageToProto(in *Image) *oneof_pb.Entry_Image {
	return &oneof_pb.Entry_Image{ImageToProto(in)}
}

func Entry_LinkToProto(in *Link) *oneof_pb.Entry_Link {
	return &oneof_pb.Entry_Link{LinkToProto(in)}
}

