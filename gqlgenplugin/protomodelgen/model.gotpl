{{ reserveImport "fmt" }}
{{ reserveImport "io" }}
{{ reserveImport "strconv" }}

{{- range $obj := .ProtoObjects }}
	{{ $pbGoImport := lookupImport $obj.Proto.GoPackage }}
	{{ $pbGoName := printf "%s.%s" $pbGoImport $obj.Proto.GoName }}

	type {{ $obj.Name }} struct {
		{{- range $f := $obj.Fields }}
			{{- if $f.IsWrapperType }}
				{{ go $f.Name }} {{ if $f.List }}[]{{ end }}*{{ lookupImport $f.Proto.GoTypePackage }}.{{ $f.Proto.GoTypeName }}
			{{- else }}
				{{ go $f.Name }} {{ if $f.List }}[]{{ end }}{{ if not $f.IsBuiltinType }}*{{ end }}{{ findGQLFieldType $f }}
			{{- end }}
		{{- end }}
	}

	func {{ $obj.Name }}ListFromRepeatedProto(in []*{{ $pbGoName }}) []*{{ $obj.Name }} {
		out := make([]*{{ $obj.Name }}, len(in))
		for i, m := range in {
			out[i] = {{ $obj.Name }}FromProto(m)
		}
		return out
	}

	func {{ $obj.Name }}FromProto(in *{{ $pbGoName }}) *{{ $obj.Name }} {
		return &{{ $obj.Name }}{
			{{- range $f := $obj.Fields }}
				{{- if $f.Proto }}
					{{- if or $f.IsBuiltinType $f.IsWrapperType }}
						{{ go $f.Name }}: in.{{ $f.Proto.GoName }},
					{{- else if $f.List }}
						{{ go $f.Name }}: List{{ findGQLFieldType $f }}FromRepeatedProto(in.{{ $f.Proto.GoName }}),
					{{- else }}
						{{ go $f.Name }}: {{ findGQLFieldType $f }}FromProto(in.{{ $f.Proto.GoName }}),
					{{- end }}
				{{- end }}
			{{- end }}
		}
	}

	func {{ $obj.Name }}ListToRepeatedProto(in []*{{ $obj.Name }}) []*{{ $pbGoName }} {
		out := make([]*{{ $pbGoName }}, len(in))
		for i, m := range in {
			out[i] = {{ $obj.Name }}ToProto(m)
		}
		return out
	}

	func {{ $obj.Name }}ToProto(in *{{ $obj.Name }}) *{{ $pbGoName }} {
		return &{{ $pbGoName }}{
			{{- range $f := $obj.Fields }}
				{{- if $f.Proto }}
					{{- if or $f.IsBuiltinType $f.IsWrapperType }}
						{{ $f.Proto.GoName }}: in.{{ go $f.Name }},
					{{- else if $f.List }}
						{{ $f.Proto.GoName }}: {{ findGQLFieldType $f }}ListToRepeatedProto(in.{{ go $f.Name }}),
					{{- else }}
						{{ $f.Proto.GoName }}: {{ findGQLFieldType $f }}ToProto(in.{{ go $f.Name }}),
					{{- end }}
				{{- end }}
			{{- end }}
		}
	}
{{ end }}

{{- range $obj := .ObjectsHasProto }}
	type {{ $obj.Name }}_Proto struct {
		{{- range $f := $obj.Fields }}
			{{- if $f.TypeProto }}
				{{ $proto := $f.TypeProto }}
				{{ $pbGoImport := lookupImport $proto.GoPackage }}
				{{ $pbGoName := printf "%s.%s" $pbGoImport $proto.GoName }}
				{{ go $f.Name }} {{ if $f.List }}[]{{ end }}*{{ $pbGoName }}
			{{- else if and $f.TypeDef (hasProto $f.TypeDef) }}
				{{ go $f.Name }} {{ if $f.List }}[]{{ end }}*{{ findGQLFieldType $f }}_Proto
			{{- else }}
				{{ go $f.Name }} {{ if $f.List }}[]{{ end }}{{ if not $f.IsBuiltinType }}*{{ end }}{{ findGQLFieldType $f }}
			{{- end }}
		{{- end }}
	}

	func {{ $obj.Name }}ListFromRepeatedProto(in []*{{ $obj.Name }}_Proto) []*{{ $obj.Name }} {
		out := make([]*{{ $obj.Name }}, len(in))
		for i, m := range in {
			out[i] = {{ $obj.Name }}FromProto(m)
		}
		return out
	}

	func {{ $obj.Name }}FromProto(in *{{ $obj.Name }}_Proto) *{{ $obj.Name }} {
		return &{{ $obj.Name }}{
			{{- range $f := $obj.Fields }}
				{{- if or $f.IsBuiltinType $f.IsWrapperType }}
					{{ go $f.Name }}: in.{{ go $f.Name }},
				{{- else if or (not $f.TypeDef) (not (hasProto $f.TypeDef)) }}
					{{ go $f.Name }}: in.{{ go $f.Name }},
				{{- else if $f.List }}
					{{ go $f.Name }}: {{ findGQLFieldType $f }}ListFromRepeatedProto(in.{{ go $f.Name }}),
				{{- else }}
					{{ go $f.Name }}: {{ findGQLFieldType $f }}FromProto(in.{{ go $f.Name }}),
				{{- end }}
			{{- end }}
		}
	}

	func {{ $obj.Name }}ListToRepeatedProto(in []*{{ $obj.Name }}) []*{{ $obj.Name }}_Proto {
		out := make([]*{{ $obj.Name }}_Proto, len(in))
		for i, m := range in {
			out[i] = {{ $obj.Name }}ToProto(m)
		}
		return out
	}

	func {{ $obj.Name }}ToProto(in *{{ $obj.Name }}) *{{ $obj.Name }}_Proto {
		return &{{ $obj.Name }}_Proto{
			{{- range $f := $obj.Fields }}
				{{- if or $f.IsBuiltinType $f.IsWrapperType }}
					{{ go $f.Name }}: in.{{ go $f.Name }},
				{{- else if or (not $f.TypeDef) (not (hasProto $f.TypeDef)) }}
					{{ go $f.Name }}: in.{{ go $f.Name }},
				{{- else if $f.List }}
					{{ go $f.Name }}: {{ findGQLFieldType $f }}ListToRepeatedProto(in.{{ go $f.Name }}),
				{{- else }}
					{{ go $f.Name }}: {{ findGQLFieldType $f }}ToProto(in.{{ go $f.Name }}),
				{{- end }}
			{{- end }}
		}
	}
{{ end }}

{{- range $enum := .Enums }}
	{{ $pbGoImport := lookupImport $enum.Proto.GoPackage }}
	{{ $pbGoName := printf "%s.%s" $pbGoImport $enum.Proto.GoName }}

	type {{ $enum.Name }} struct {
		Proto {{ $pbGoName }}
	}

	func {{ $enum.Name }}ListFromRepeatedProto(in []{{ $pbGoName }}) []*{{ $enum.Name }} {
		out := make([]*{{ $enum.Name }}, len(in))
		for i, m := range in {
			out[i] = {{ $enum.Name }}FromProto(m)
		}
		return out
	}

	func {{ $enum.Name }}FromProto(in {{ $pbGoName }}) *{{ $enum.Name }} {
		return &{{ $enum.Name }}{Proto: in}
	}

	func {{ $enum.Name }}ListToRepeatedProto(in []*{{ $enum.Name }}) []{{ $pbGoName }} {
		out := make([]{{ $pbGoName }}, len(in))
		for i, m := range in {
			out[i] = {{ $enum.Name }}ToProto(m)
		}
		return out
	}

	func {{ $enum.Name }}ToProto(in *{{ $enum.Name }}) {{ $pbGoName }} {
		return in.Proto
	}

	func (e {{ $enum.Name }}) MarshalGQL(w io.Writer) {
		fmt.Fprint(w, strconv.Quote(e.Proto.String()))
	}

	func (e *{{ $enum.Name }}) UnmarshalGQL(v interface{}) error {
		str, ok := v.(string)
		if !ok {
			return fmt.Errorf("enums must be strings")
		}

		e.Proto = {{ $pbGoName }}({{ $pbGoName }}_value[str])
		return nil
	}
{{ end }}
