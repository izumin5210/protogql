{{ reserveImport "fmt" }}
{{ reserveImport "io" }}
{{ reserveImport "strconv" }}

{{ range $obj := .Objects }}
	{{ $pbGoImport := lookupImport $obj.Proto.GoPackage }}
	{{ $pbGoName := printf "%s.%s" $pbGoImport $obj.Proto.GoName }}

	type {{ $obj.Name }} struct {
		{{ range $f := $obj.Fields }}
			{{ go $f.Name }} {{ if $f.List }}[]{{ end }}{{ if not $f.IsBuiltinType }}*{{ end }}{{ findGQLFieldType $f }}
		{{ end }}
	}

	func {{ $obj.Name }}ListFromRepeatedProto(in []*{{ $pbGoName }}) []*{{ $obj.Name }} {
		out := make([]*{{ $obj.Name }}, len(in))
		for i, m := range in {
			out[i] = {{ $obj.Name }}FromProto(m)
		}
		return out
	}

	func {{ $obj.Name }}FromProto(in *{{ $pbGoName }}) *{{ $obj.Name }} {
		return &{{ $obj.Name }}{
			{{ range $f := $obj.Fields }}
				{{ if $f.Proto }}
					{{ if $f.IsBuiltinType }}
						{{ go $f.Name }}: in.{{ $f.Proto.GoName }},
					{{ else if $f.List }}
						{{ go $f.Name }}: List{{ findGQLFieldType $f }}FromRepeatedProto(in.{{ $f.Proto.GoName }}),
					{{ else }}
						{{ go $f.Name }}: {{ findGQLFieldType $f }}FromProto(in.{{ $f.Proto.GoName }}),
					{{ end }}
				{{ end }}
			{{ end }}
		}
	}

	func {{ $obj.Name }}ListToRepeatedProto(in []*{{ $obj.Name }}) []*{{ $pbGoName }} {
		out := make([]*{{ $pbGoName }}, len(in))
		for i, m := range in {
			out[i] = {{ $obj.Name }}ToProto(m)
		}
		return out
	}

	func {{ $obj.Name }}ToProto(in *{{ $obj.Name }}) *{{ $pbGoName }} {
		return &{{ $pbGoName }}{
			{{ range $f := $obj.Fields }}
				{{ if $f.Proto }}
					{{ if $f.IsBuiltinType }}
						{{ $f.Proto.GoName }}: in.{{ go $f.Name }},
					{{ else if $f.List }}
						{{ $f.Proto.GoName }}: List{{ findGQLFieldType $f }}ToRepeatedProto(in.{{ go $f.Name }}),
					{{ else }}
						{{ $f.Proto.GoName }}: {{ findGQLFieldType $f }}ToProto(in.{{ go $f.Name }}),
					{{ end }}
				{{ end }}
			{{ end }}
		}
	}
{{ end }}

{{ range $enum := .Enums }}
	{{ $pbGoImport := lookupImport $enum.Proto.GoPackage }}
	{{ $pbGoName := printf "%s.%s" $pbGoImport $enum.Proto.GoName }}

	type {{ $enum.Name }} struct {
		Proto {{ $pbGoName }}
	}

	func {{ $enum.Name }}ListFromRepeatedProto(in []{{ $pbGoName }}) []*{{ $enum.Name }} {
		out := make([]*{{ $enum.Name }}, len(in))
		for i, m := range in {
			out[i] = {{ $enum.Name }}FromProto(m)
		}
		return out
	}

	func {{ $enum.Name }}FromProto(in {{ $pbGoName }}) *{{ $enum.Name }} {
		return &{{ $enum.Name }}{Proto: in}
	}

	func {{ $enum.Name }}ListToRepeatedProto(in []*{{ $enum.Name }}) []{{ $pbGoName }} {
		out := make([]{{ $pbGoName }}, len(in))
		for i, m := range in {
			out[i] = {{ $enum.Name }}ToProto(m)
		}
		return out
	}

	func {{ $enum.Name }}ToProto(in *{{ $enum.Name }}) {{ $pbGoName }} {
		return in.Proto
	}

	func (e {{ $enum.Name }}) MarshalGQL(w io.Writer) {
		fmt.Fprint(w, strconv.Quote(e.Proto.String()))
	}

	func (e *{{ $enum.Name }}) UnmarshalGQL(v interface{}) error {
		str, ok := v.(string)
		if !ok {
			return fmt.Errorf("enums must be strings")
		}

		e.Proto = {{ $pbGoName }}({{ $pbGoName }}_value[str])
		return nil
	}
{{ end }}
